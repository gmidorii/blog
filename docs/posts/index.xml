<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Green Software Engineer Blog</title>
    <link>https://midorigreen.github.io/blog/posts/</link>
    <description>Recent content in Posts on Green Software Engineer Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp</language>
    
	<atom:link href="https://midorigreen.github.io/blog/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://midorigreen.github.io/blog/posts/2017-05-27_junit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://midorigreen.github.io/blog/posts/2017-05-27_junit/</guid>
      <description>概要 JUnitを利用した、Javaのユニットテストを作成する際の基本的な部分について記載しました。
JUnit実践入門の内容 + 経験から記載しました。
テストコード基本 ユニットテスト対象物 テストクラスに対する、テスト対象物はテストクラスのコードのみとします。そのため、外部オブジェクトの作成等は基本的にモック化します。
(外部クラスのコードのテストは、外部クラスのテスト上で行えば良いとの考え方です。)
またテストメソッドの対象物ですが、基本的に publicメソッド を対象とします。
privateメソッドは、publicメソッドを正確にテストすることで、同時にテストされていなければ、ならないと考えているためです。
各命名と役割    命名 役割 備考     XXXTest テストクラス名    xxx_条件_結果 テストメソッド - xxx()メソッド - @Testアノテーションを付ける   sut テスト対象オブジェクト変数名 - テスト対象のオブジェクトを明確化するために同一名称で宣言する。 - System Under Testの略   setUp() テストごとの前処理 - 各テスト実行ごとの前処理を記載 - @Before アノテーションを付ける   tearDown() テストごとの後処理 - 各テスト実行ごとの後処理を記載 - @After アノテーションを付ける   setUpClass() テストクラスごとの前処理 - テストクラス内のテストが一つでも実行される前の処理を記載 - @BeforeClass アノテーション記載 - public static methodで宣言   tearDownClass() テストクラスごとの後処理 - テストクラス内のテストが全て実行された後の処理を記載 - @AfterClass アノテーション記載 - public static methodで宣言    テストのフェーズ  事前準備 = set up</description>
    </item>
    
    <item>
      <title></title>
      <link>https://midorigreen.github.io/blog/posts/2017-05-31_golang-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://midorigreen.github.io/blog/posts/2017-05-31_golang-sort/</guid>
      <description>GolangのSort処理について GolangのSort処理 GolangのSort処理について、まとめました。
(// package sort と記載があるサンプルコードは、Golang本体のソースコードです)
Sort Sort Interface Golangでは、structのソートを行うため、sort.Interfaceを実装する必要があります。
(実際はGo1.8以降、下記の sort.Slice() を利用して、ソートすることができるようになりました。参考)
// sort.Interface type Interface interface { // Len is the number of elements in the collection. Len() int // Less reports whether the element with // index i should sort before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }     メソッド 特徴     Len() int 配列・リストの要素数   Less(i, j int) bool i &amp;lt; j を満たすかの真偽値   Swap(i,j int) iとjの要素を入れ替える    Sortの方法 標準パッケージで対応している型は下記になります。 - float64 - int - string</description>
    </item>
    
    <item>
      <title></title>
      <link>https://midorigreen.github.io/blog/posts/2017-06-01_golang-tokyo6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://midorigreen.github.io/blog/posts/2017-06-01_golang-tokyo6/</guid>
      <description>golang.tokyo 6 (2017/06/01) 概要 golang.tokyo #6 に参加しましたので、レポートを記載いたします。
(会場は、DeNAさんでお寿司(食べ損ねた)とお酒をご用意いただいておりました。)
下記は各セッションのまとめです。
Gopher Fest 2017 @tenntenn さん
スライド
[https://www.slideshare.net/takuyaueda967/gopher-fest-2017:embed]
概要 サンフランシスコで開催されるGoSFが主催のイベントの参加レポートです。 セッションの中のひとつ The state of Go のお話
The state of Go Go1.9での仕様変更や標準ライブラリの改善についてのお話 (余談ですが、tip.golang.orgで最新のmasterのドキュメントが見れるそうです)
 Go1.9は5/1にコードフリーズ済み  残りはバグフィックスのみ  リファクタリングを安全にする方法  Codebase Refactoring  Goで安全にリファクタできるのか?  定数の場合は問題なし 関数はラップして引き継げば問題なし 型の場合→ 問題有り 型を作る → メソッドが引き継げない 埋め込み → キャストができない Go1.9でAlias導入  言語仕様変更  Alias を作成できる 型のエイリアスを定義できる こんな感じで type A = http.Client 完全に同じ型 キャスト不要 エイリアスの方ではメソッドを定義できない  標準ライブラリ変更  math/bits ビット演算に便利なライブラリ syc.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://midorigreen.github.io/blog/posts/2017-06-15_bayeux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://midorigreen.github.io/blog/posts/2017-06-15_bayeux/</guid>
      <description>Bayeux プロトコル はじめに Pub/Sub Messagingを勉強するにあたって、Bayeuxプロトコルでの実装があるとのことだったので、Bayeux プロトコル日本語訳を読んでメモを取ってみました。
(WebSocketがもはや主流で枯れた仕様な気もしていますが、せっかく読んだので公開しようかと思います)
Bayeuxプロトコル概要  Webサーバー間でメッセージを非同期にやりとりするためのプロトコル メッセージは名前付きチャネルを経て、ルーティング及び送達される  サーバ &amp;lt;=&amp;gt; クライアント  ajaxを利用したサーバープッシュ型のテクニック=「comet」 準拠要求  全てのMUST及びREQUIREDを満たし、かつ、全てのSHOULDを満たすものは、&amp;rdquo;完全準拠(unconditionally compliant)&amp;rdquo; １つでもSHOULDを満たさないモノは「条件付き準拠(conditionally compliant)」  ワード定義  メッセージ サーバーとクライアント間で交換されるJSONオブジェクトである イベント Bayeuxプロトコルを用いて送られるアプリケーション固有のデータである チャネル 名前付きのイベント送達先（と送信元）。イベントはチャネルに対して投稿され、受信者はチャネルからこれを受け取る   HTTPプロトコル  リクエスト/レスポンス型のプロトコル クライアント -&amp;gt; サーバー  リクエストメソッド(GET,POST) URI  サーバー -&amp;gt; クライアント  ステータスライン プロトコルバージョン  基本的にサーバー -&amp;gt; クライアントへはクライアントの要求なしに通信を走らせない Bayeuxでは、双方向の非同期通信を走らせるためサーバー・クライアント間で複数コネクションをサポートしている  通常アクセス用コネクション ロングポーリング用コネクション  (MUST NOT)Bayeuxプロトコルも、サーバーが全てのアプリケーションに対して処理を行うために3本以上のコネクションをはらない  様々なルール  (MUST) クライアントはブラウザのシングルオンポリシーを尊守しなければならない  シングルオンポリシー = JSからはそれがダウンロードされたサーバー以外への接続は許可されない  2コネクション処理  (MUST) Bayeux実装はHTTPのパイプライン処理を制御し、リクエスト順を保持して実行しなければならない  ポーリング  レスポンスを受け取った後、メッセージをサーバーに対して送信する 次のメッセージを受け取れるようにする処理 Bayeux実装は、ロングポーリングと呼ばれる形式のポーリングをサポートする必要がある  接続ネゴシエーション  接続の際、コネクション/認証/を交換して合意するネゴシエーションが行われる その際、ハンドシェークメッセージがかわされる  クライアントの状態  -------------++------------+-------------+----------- +------------ State/Event || handshake | Timeout | Successful | Disconnect || request | | connect | request || sent | | response | sent -------------++------------+-------------+----------- +------------ UNCONNECTED || CONNECTING | UNCONNECTED | | CONNECTING || | UNCONNECTED | CONNECTED | UNCONNECTED CONNECTED || | UNCONNECTED | | UNCONNECTED -------------++------------+-------------+------------+------------  Bayeuxにおける名前や識別子に用いられる文字はBNF(バッカスナウア）記法  // BNF記法 alpha = lowalpha | upalpha lowalpha = &amp;quot;a&amp;quot; | &amp;quot;b&amp;quot; | &amp;quot;c&amp;quot; | &amp;quot;d&amp;quot; | &amp;quot;e&amp;quot; | &amp;quot;f&amp;quot; | &amp;quot;g&amp;quot; | &amp;quot;h&amp;quot; | &amp;quot;i&amp;quot; | &amp;quot;j&amp;quot; | &amp;quot;k&amp;quot; | &amp;quot;l&amp;quot; | &amp;quot;m&amp;quot; | &amp;quot;n&amp;quot; | &amp;quot;o&amp;quot; | &amp;quot;p&amp;quot; | &amp;quot;q&amp;quot; | &amp;quot;r&amp;quot; | &amp;quot;s&amp;quot; | &amp;quot;t&amp;quot; | &amp;quot;u&amp;quot; | &amp;quot;v&amp;quot; | &amp;quot;w&amp;quot; | &amp;quot;x&amp;quot; | &amp;quot;y&amp;quot; | &amp;quot;z&amp;quot; upalpha = &amp;quot;A&amp;quot; | &amp;quot;B&amp;quot; | &amp;quot;C&amp;quot; | &amp;quot;D&amp;quot; | &amp;quot;E&amp;quot; | &amp;quot;F&amp;quot; | &amp;quot;G&amp;quot; | &amp;quot;H&amp;quot; | &amp;quot;I&amp;quot; | &amp;quot;J&amp;quot; | &amp;quot;K&amp;quot; | &amp;quot;L&amp;quot; | &amp;quot;M&amp;quot; | &amp;quot;N&amp;quot; | &amp;quot;O&amp;quot; | &amp;quot;P&amp;quot; | &amp;quot;Q&amp;quot; | &amp;quot;R&amp;quot; | &amp;quot;S&amp;quot; | &amp;quot;T&amp;quot; | &amp;quot;U&amp;quot; | &amp;quot;V&amp;quot; | &amp;quot;W&amp;quot; | &amp;quot;X&amp;quot; | &amp;quot;Y&amp;quot; | &amp;quot;Z&amp;quot; digit = &amp;quot;0&amp;quot; | &amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | &amp;quot;3&amp;quot; | &amp;quot;4&amp;quot; | &amp;quot;5&amp;quot; | &amp;quot;6&amp;quot; | &amp;quot;7&amp;quot; | &amp;quot;8&amp;quot; | &amp;quot;9&amp;quot; alphanum = alpha | digit mark = &amp;quot;-&amp;quot; | &amp;quot;_&amp;quot; | &amp;quot;!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://midorigreen.github.io/blog/posts/2017-06-19_go-package/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://midorigreen.github.io/blog/posts/2017-06-19_go-package/</guid>
      <description>Gopackage Golangのパッケージ構成について golangで開発するにあたって、パッケージ構成がよくわからなかったため、調べてみました。
当記事では、下記に焦点をあてて調べてみました。 - packageの分け方 - pacakge内でのファイルの分割 - ファイル内のコードの書き方
パッケージ構成 @benbjohnson さんの記事を参考とした例です。
Good Practice (by @benbjohnson) 下記の4点を考慮したアプローチ
 Root package is for domain types Group subpackages by dependency Use a shared mock subpackage Main package ties together dependencies  1. Root package is for domain types ドメインとは、データとプロセスがどのように相互作用を起こすかを記述する、高次元の言語のことです。
ドメインは、技術的なバックグラウンドに依存することはありません。
Root packageには、このドメインタイプを配置します。Root package内は、
simpleなstructとstuctの振る舞いを定義したinterfaceのみで構成されます。
The root package should not depend on any other package in your application!
→ Root packageはアプリケーション上の他のいかなるパッケージにも依存すべきでない</description>
    </item>
    
    <item>
      <title></title>
      <link>https://midorigreen.github.io/blog/posts/2017-06-25_sync-pool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://midorigreen.github.io/blog/posts/2017-06-25_sync-pool/</guid>
      <description>概要 標準パッケージのsync.Poolを利用して、ファイルの中身を常にメモリ上(=キャッシュ)におきたかったのですが、動作が不定のためうまく利用できなかった話です。
Go version % go version go version go1.8.1 darwin/amd64  sync.Pool概要 概要としては、以下の認識です
 オブジェクトを一時的に、保持するための機能 再利用されるオブジェクトをキャッシュする利用法 複数のgoroutineで安全に利用可能 copy禁止(noCopystructが埋め込まれている)  メソッド Get func (p *Pool) Get() interface{}
 Poolよりitemを取り出す 取り出されたitemはPoolから削除 Putで入れた値とGetで取り出す値の関係を考慮すべきでない  Put func (p *Pool) Put(x interface{})
 Poolに値を追加する  動作確認 下記のコードを利用して、Getした際とPutした際の挙動を確認してみました。
https://github.com/midorigreen/gopool/blob/master/main.go
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;sync&amp;quot; ) var pool = sync.Pool{ New: func() interface{} { return &amp;quot;init&amp;quot; }, } func main() { mux := http.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://midorigreen.github.io/blog/posts/2017-07-01_gosns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://midorigreen.github.io/blog/posts/2017-07-01_gosns/</guid>
      <description>GoSNS 概要 [https://github.com/midorigreen/gosns:embed:cite]
AmazonSNS likeな、簡易メッセージングAPIサーバーを練習がてら書いてみました。
(Amazon SNSちゃんと使ったことないので、ぜんぜん違うかもしれないですが&amp;hellip;)
モデルは、Pub/Subを意識しています。
機能概要  Channel登録 Channelに対して購読登録  購読手段はSlackのWebHook一択(Mail等の対応も検討中)  新規Channelの開設 Handshakeリクエスト  簡易API Doc一覧 メルカリ製のgo-httpdocを利用してドキュメント生成しました。
[https://github.com/mercari/go-httpdoc:embed:cite]
 /meta/channel
 /meta/subscribe /meta/handshake
 /topic
  I/F 基本POSTリクエストでサーバーとやり取りをします。
POSTのBodyに下記、Request構造のJSONを書き込んでリクエストします。
Channel登録 (/meta/channel) 新規に開設したい、Channelを登録します。
Request    名前 型 概要     channel String 登録したいchannel名    サンプル
{ &amp;quot;channel&amp;quot;: &amp;quot;golang&amp;quot; }  Response JSON構造
   名前 型 概要     channel String 登録したchannel名   successful String 登録成否   error (optional) String エラー    購読登録 (/meta/subscribe) 購読の登録をします。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://midorigreen.github.io/blog/posts/2017-07-09_learn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://midorigreen.github.io/blog/posts/2017-07-09_learn/</guid>
      <description>学びたいことについて 概要 エンジニアとして、どのあたりを学んでいこうかなぁとの備忘録
項目 Golang 最近ずっと利用しているメイン言語です。仕事上ではJavaを利用することが多いですが、 書いている時間も量もそろそろ超えてくるのではと思っています。
好きなところはこんな感じです。 - ビルドしたバイナリがあればどの環境でも動かしやすい点 - 型あり - Httpサーバーの起動しやすさ - プログラマーならたぶん誰でも読める - ドキュメントが読みやすい
学びたいこと  パッケージの構成方法  自由に書けてしまってどこに何を書くかが明確になっていない パッケージの切り方 各ファイル内のinterface,strcut,methodの構成  周辺ツールの利用方法  ツールが充実しているのことで、きっちり使い方を抑えたい(pprofとか)  実務上でのコードレベル  OSSのライブラリ等を読んでみる等ですかね  体系的な知識  Webでの情報がメインのため、体系的な知識が身についてない疑惑 書籍でまとまったものがあれば一度読むのも良いかも   次のステップ  標準ライブラリ読む OSS読む 本をよむ  Go言語によるWebアプリケーション開発  実務での利用  布教   クラウド 実務できっちり利用できていない分、プライベートで学んでおかないと遅れが目立ってしまう印象です。
学びたいこと  GAE/Goの動作方法 k8sについて GCP主要サービス理解  そもそものサービスについてあまり知らない  AWS(ざっくり)  次のステップ  GAEにGoサービスを載せてみる WEB+DB PRESS Vol.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://midorigreen.github.io/blog/posts/2017-08-05_vim-go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://midorigreen.github.io/blog/posts/2017-08-05_vim-go/</guid>
      <description> vim-go設定 概要 goをvimでかけるよう設定してみました。
やったこと  vim-go導入   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://midorigreen.github.io/blog/posts/2017-08-06_k8s/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://midorigreen.github.io/blog/posts/2017-08-06_k8s/</guid>
      <description>kubernetes 概要 WEB DB Pressの記事を参考にk8sを利用してみました。
詳しい内容は、記事をご参照いただければと思います。(非常にわかりやすい記事でした)
下記は、記事に書いてあるコマンドのままですが、メモ書き程度に思っていただければ。
コマンド gcloud側の設定 # project の設定 % gcloud config set project xxxx # ゾーンの設定 % gcloud config set compute/zone asia-northeast1-a # 認証設定 % gcloud auth login  コンテナクラスタ起動 # クラスタ起動 % gcloud container clusters create one \ --cluster-version=1.6.7 \ --machine-type=g1-small Creating cluster one...done. Created [https://container.googleapis.com/v1/projects/xxxxx/zones/asia-northeast1-a/clusters/one]. kubeconfig entry generated for one. NAME ZONE MASTER_VERSION MASTER_IP MACHINE_TYPE NODE_VERSION NUM_NODES STATUS one asia-northeast1-a 1.6.7 35.190.233.232 g1-small 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://midorigreen.github.io/blog/posts/2017-08-16_machine-learning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://midorigreen.github.io/blog/posts/2017-08-16_machine-learning/</guid>
      <description>機械学習初心者 概要 お盆休みを利用して、Machine LearningをTensorFlowのTutorialsを通して触れてみました。
解いた問題は、手書き数値の認識です。
Machine Learning おこなっていることは、任意のグラフに対して近似する関数(=Model)を見つけること
用語  データ  (Training用) データとそのラベルのセットを持つ必要がある ex) 手書き文字 &amp;lt;-&amp;gt; 書いてある文字 (Test用) accuracyを計測するためのデータ 同様にデータと正解ラベルを持つ必要がある  weight  入力値への重みテンソル(行列)  bias  weightと入力値の積をずらす  x  入力値  y  出力  activation function ``` evidence = W * x + b  Tensor W = weight x = input
b = bias ``` - softmax function - evidence(活性化関数=activation functionの結果)を確率へと変換する - 確率より 0 &amp;lt;= y &amp;lt;= 1 - loss function - 期待値と実際の結果の差分を計測する関数 - ※ loss functionの結果を0に近づけることが目標(=期待値と実際の値が一致する)</description>
    </item>
    
    <item>
      <title></title>
      <link>https://midorigreen.github.io/blog/posts/2017-09-18_up/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://midorigreen.github.io/blog/posts/2017-09-18_up/</guid>
      <description>Serverless App作成ツール Up を利用してみた 概要 up と呼ばれるツールを利用してみました。
(Introductionをそのまま試してみただけです。)
https://github.com/apex/up
upとは? Serverless Applicationを簡単に作成、デブロイできるツールです。
現状の構築環境と方式は、下記のとおりです。 - 構築環境 - AWS - 方式 - API GateWay + AWS Lambda
対応言語 個人的にはGolangに対応しているのが良いですね。
(Lambda自体はまだ、Golang対応していないので) - Node.js - Golang (← GOOD) - Python - Crystal - 静的サイト
手順 こちらのサイト に記載のまんまです。
 Install curl直接 or npm ```sh
curl版 % curl -sfL https://raw.githubusercontent.com/apex/up/master/install.sh | sh
  npm版 (内部で上記curlを叩いているだけです) % npm i -g up
2. AWS Credenstialsの設定 `~/.aws/credentials` に追記が楽かと思います。  [go-up-test] aws_access_key_id = xxxxxxxx aws_secret_access_key = xxxxxxxxxxxxxxxxxxxxxxxx</description>
    </item>
    
    <item>
      <title></title>
      <link>https://midorigreen.github.io/blog/posts/2017-11-19_ijaas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://midorigreen.github.io/blog/posts/2017-11-19_ijaas/</guid>
      <description>ijaas 概要 ijaasを導入に当たって、変なところで詰まったので残しておきます。
ijaasとは https://github.com/google/ijaas
 Make IntelliJ as a Java server that does autocompletion for Vim.
 IntelliJをサーバーとして立てて、Vim からAPI経由で各種機能を
利用できるようにしている模様です。
基本は、 README.md に記載の通りの手順で問題ないはずです。
詰まった点 1. PluginがInstallできない Setting &amp;gt; Plugins &amp;gt; install plugin from disk 実行時に、下記エラーが発生
画像
解消 IntelliJのバージョンが合ってなかったため、発生していた模様です。
build.gradle
def intellijVersion = &#39;IC-2017.1.5&#39; if (project.hasProperty(&#39;intellij.version&#39;)) { intellijVersion = getProperty(&#39;intellij.version&#39;) }  intellij.version で切り替えができる模様のため、
build.properties を追加して上げれば良いです。
intellij.version=IC-2017.2.6  2. IntelliJ上からbuildPluginするとIdea取得で失敗 S3より、Ideaを取得する部分で失敗していました。
解消 コンソールより実行で解消できました。
% gradle buildPlugin  3. NeoVimから実行できない ch_open がNeoVimに実装されていない(?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://midorigreen.github.io/blog/posts/2017-11-4_vim-go-option/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://midorigreen.github.io/blog/posts/2017-11-4_vim-go-option/</guid>
      <description>vim-goの便利コマンド一覧 概要 Goを開発している際に、vim-goを利用しています。
https://github.com/fatih/vim-go
最低限のコマンドしか利用できていなかったため、
便利なコマンドを再洗い出ししてみます。
(個人的なまとめの意味合いが強いです。)
Commands 下記を参照しております。
https://github.com/fatih/vim-go/blob/master/doc/vim-go.txt
:GoRun go run コマンドに相当します。
vim上から実行できるところが便利です。
:GoBuild go build コマンドに相当します。build後のバイナリは排出しないです。
buildが成功するかどうかを確認する際に利用すると便利です。
成功すると、下記のように出力されます。
vim-go: SUCCESS  失敗すると、quickfix windowに一覧が出力されます。
1 main.go|16| syntax error: unexpected semicolon or newline, expecting comma or } Quickfix go build -i . errors vim-go: FAILED  :GoDef カーソル以下の、宣言元にjumpできます。
実際の実装がどうなっているか確認したりする際に利用します。
gd で同等の動作をします。
(基本的には、 gd で移動することが多い印象です。)
:GoCallers カーソル以下のfuncの、呼び出し元を一括検索できます。
(ファイル全検索していたのが、馬鹿らしく思えます..)
注意点 として、複数packageで検索したい場合は、 :GoGuruScope でスコープを設定します。
(どのディレクトリ以下で検索をかけたいかを設定するイメージです。)
:GoGuruScope github.com/midorigreen/gprof  Sample: selectPeco()のカーソル上で
:GoCallers  quickfix window</description>
    </item>
    
    <item>
      <title></title>
      <link>https://midorigreen.github.io/blog/posts/2017_09_19_cors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://midorigreen.github.io/blog/posts/2017_09_19_cors/</guid>
      <description>CORSについて 概要 今更ながら、CORSについてちゃんと知っておこうと思い、まとめました。
CORSとは  Cross Origin Resource Sharingの略 現在のブラウザではSame Origin Policyが適用されている  Webサイト上の情報を別の悪意のあるサイトに流用されないようにする仕組み  ただ信頼性のあるサイトに対してのみアクセスを許可する仕組み(= CORS)  仕組み 1. Originを超えたリクエストする際のRequest HeaderにはOriginが付与される GET /hoge HTTP/1.1 Origin: https://xxxx.com  2. Originが信頼できるサイトであれば、Response HeaderにAccess-Control-Allow-Originを付与する HTTP/1.1 200 OK Access-Control-Allow-Origin: https://xxxx.com  (補足)
どのサイトからのOrigin超えのアクセス許可をしたい場合は、ワイルドカードが利用できる
HTTP/1.1 200 OK Access-Control-Allow-Origin: *  nginxでCORSを実現する方法  add_headerを利用する
 Response Headerにそのまま追記される
http { server { listen 8080; server_name localhost; charset UTF-8; location /hoge/ { proxy_http_version 1.1; proxy_pass http://xxxxxx.com/api/; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Methods &amp;quot;POST, GET, OPTIONS&amp;quot;; add_header Access-Control-Allow-Headers &amp;quot;Origin, Authorization, Accept&amp;quot;; add_header Access-Control-Allow-Credentials true } } }    Golang でProxyサーバーを作成 ※ Proxyの仕組みをきちんと使えていないNGコード</description>
    </item>
    
    <item>
      <title></title>
      <link>https://midorigreen.github.io/blog/posts/2017_12_09_shingle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://midorigreen.github.io/blog/posts/2017_12_09_shingle/</guid>
      <description>Go実装の最適化ゲーム 概要 同僚がこのコード書ける Java のライブラリない？と言ってきたので、
Go で実装し返しました。(遊び)
書いたコードがひどそうだったので、最適化をするゲームをしてみました。
お題 配列が与えられた際に、最小/最大サイズの文字列を前から順に結合して取得したい とのことでした。(何言ってるかわからない)
例 例を挙げるとわかりやすいかと思います。
input: [a, b, c, d, e]
=&amp;gt; output: [ab abc abcd abcde bc bcd bcde cd cde de]
実装 パート1 まず、最初に思いついて書いたコードが下記になります。
なんかこう色々まずそうです。
Go Playground
func initialShingle(min, max int, arr []string) []string { res := []string{} if min &amp;gt; max { return res } for i := 0; i &amp;lt; len(arr); i++ { cmin := min for j := i; j+cmin &amp;lt; len(arr)+1; j++ { if len(arr[i:j+cmin]) &amp;gt; max { break } var s string for _, v := range arr[i : j+cmin] { s += v } res = append(res, s) } } return res }  閑話休題 とりあえず、動作確認のためテストコードを書きます。</description>
    </item>
    
  </channel>
</rss>